### 设计模式6-结构型设计模式-适配器模式

编程是一门艺术，大批量的改动显然是非常丑陋的做法，用心的琢磨写的代码让它变的更美观。

#### 1.适配器设计模式(Adapter)

适配器模式是将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。



#### 2.适配器设计模式的优点

- 客户端通过适配器可以透明地调用目标接口。
- 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。
- 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。
- 在很多业务场景中符合开闭原则。



#### 3.适配器设计模式的不足

- 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。
- 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。



#### 4.适配器模式的实现思路

定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。当使用者调用业务接口的时候，其实调用的逻辑是组件库中的功能。

适配器模式包含以下主要角色：

* 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口，暴露给使用者。

* 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口，实际功能的提供者。

* 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。简单的说就是：**实现target接口，继承适配者**。



#### 5.适配器模式的实现

```java
//所期待的业务接口
public interface  IEffect {
    public void render();
}

//被访问或者适配的现存组件
public class Adaptee {
    public void doRender()
    {
        System.out.println("适配者中的逻辑");
    }
}
//继承现在有的组件  实现目标业务接口
public class ClassAdapter extends Adaptee implements IEffect{

    @Override
    public void render() {
        doRender();
    }
}


 public static void main(String[] args) {
        IEffect iEffect=new ClassAdapter();
        iEffect.render();
 }


```



#### 6.模式的应用场景

- 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。
- 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。